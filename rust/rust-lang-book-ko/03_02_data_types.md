# 03-02 Data Types

러스트에서 사용되는 모든 값들은 특정한 *타입*을 갖는다. 타입은 데이터를 어떻게 다룰지 다룰지 알 수 있도록 러스트에게 어떤 유형의 데이터를 다루는 것인지 알려준다. 여기서 두 종류의 데이터 타입 하위 집합을 다룰 것이다 : 스칼라와 컴파운드.

러스트는 *정적 타입* 언어라는 것을 계속 염두에 두어야 한다. 이 말은 러스트가 모든 변수의 타입을 컴파일 타임에 알고 있어야 한다는 뜻이다. 컴파일러는 대체로 사용하는 값과 변수를 어떻게 사용하는지를 바탕으로 타입을 추론할 수 있다. 다만 여러 가지 타입이 가능한 경우에, 예를 들어 2장에서 `String`을 `parse`를 이용하여 숫자 타입으로 바꾸었을 때 처럼, 타입 어노테이션은 반드시 추가되어야 한다.

```rust
let guess: u32 = "42".parse().expect("Not a number!");
```

만약 여기 타입 어노테이션을 달아놓지 않는다면, 러스트는 다음과 같은 오류를 낼 것이다. 이 오류는 우리가 어떤 타입을 사용하길 원하는지 알기 위해서 컴파일러에게 더 많은 정보를 제공해줘야 함을 뜻한다.

```bash
error[E0282]: type annotations needed
 --> src/main.rs:2:9
  |
2 |     let guess = "42".parse().expect("Not a number!");
  |         ^^^^^
  |         |
  |         cannot infer type for `_`
  |         consider giving `guess` a type
```

다른 데이터 타입의 경우 다른 타입 어노테이션을 볼 수 있다.

## Scalar Types 스칼라 타입

*스칼라* 타입은 하나의 값을 표현한다. 러스트는 네 개의 스칼라 타입을 가지고 있다: 정수, 부동 소수점 소수, boolean, 문자. 이 타입은 다른 언어에서도 보아 왔겠지만, 이를 러스트에서는 어떻게 동작하는지 알아보자.

### Integer

*정수*는 소수부가 없는 숫자이다. 앞선 장에서는 `u32` 타입의 정수형을 사용하였다. 이 타입의 선언은 부호가 없는 32비트 변수임을 나타낸다. (부호가 있는 타입은 `u` 대신 `i`로 시작한다.) 아래 표는 러스트에서 사용되는 정수형을 보여준다. signed, unsigned로 나뉜 다른 열의 타입을 사용하여 정수 값의 타입을 선언할 수 있다.

| Length | Signed | Unsigned |
| ------ | ------ | -------- |
| 8 bit  | i8     | u8       |
| 16 bit | i16    | u16      |
| 32 bit | i32    | u32      |
| 64 bit | i64    | u64      |
| arch   | isize  | usize    |

각각의 타입은 signed 혹은 unsigned이며 명시된 크기를 갖는다. signed, unsigned는 이 숫자가 음수가 될 수 있는지 없는지 여부를 나타낸다. 다르게 말하면, 숫자가 부호를 가져야 하는 경우(signed), 항상 양수이기 때문에 부호가 따로 필요 없는 경우(unsigned)이다.

Signed 숫자는 2의 보수를 사용하여 저장된다.

각각의 signed variant는 숫자를 - (2<sup>n-1</sup>) 에서 2<sup>n-1</sup> - 1 까지의 숫자를 사용한다. 이 때 n은 해당 variant가 사용하는 비트의 수와 같다. 따라서 `i8`은 - (2<sup>7</sup>) 에서 2<sup>7</sup> - 1까지, -128에서 127까지의 값을 저장할 수 있다. unsigned variant는 0에서 2<sup>n</sup> - 1 까지의 값을 저장할 수 있으며, `u8`의 경우 0에서 255까지 저장할 수 있다.

추가로, `isize`와 `usize` 타입은 컴퓨터 환경이 64-bits인지 아닌지에 따라 결정된다. 64-bit 아키텍쳐의 경우 64 bit를, 32-bit 아키텍쳐의 경우 32 bit를 가지게 된다.

아래 테이블과 같은 정수형 리터럴을 사용할 수 있다. byte 리터럴을 제외하고 모든 정수형 리터럴은 `57u8`과 같은 타입 접미사와 `1_000`과 같이 시각적인 구분을 위한 `_`의 사용을 허용합니다.

| Number Literals | Example       |
| Decimal         | `98_222`      |
| Hex             | `0xff`        |
| Octal           | `0o77`        |
| Binary          | `0b1111_0000` |
| Byte(`u8` only) | `b'A'`        |

그렇다면 어떤 타입의 정수를 사용해야 할까? 확실하게 정해진 경우가 아니면 러스트의 기본 값인 i32가 일반적으로는 좋은 선택이다. 이는 일반적으로 가장 빠르기 때문. `isize` 혹은 `usize`는 주로 컬렉션 따위를 인덱싱할 때 사용된다.

  Integer Overflow

  0에서 255 사이의 값을 가질 수 있는 `u8` 타입의 변수가 있다고 하자. 만약 이 값을 허용하는 범위 바깥의 값-256 등-으로 바꾸고자 한다면, *정수 오버플로우 integer overflow*가 발생하게 된다. 러스트는 이 상황을 포함하는 흥미로운 규칙이 있다. 디버그 모드에서 컴파일 할 경우, 러스트는 런타임에 프로그램을 오류에 빠뜨릴 수 있는 정수 오버플로우에 대한 검사를 포함한다. 러스트는 프로그램이 오류로 인해 종료될 때 `panicking`이라는 용어를 사용한다. 이에 대해서는 9장에 더욱 자세히 나와 있다.

  `--release`를 이용하여 릴리즈 모드에서 컴파일을 할 경우, 러스트는 정수 오버플로우에 대해 체크를 하지 않는다. 대신에, 정수 오버플로우가 발생할 경우, 러스트는 *2의 보수 래핑two's complement wrapping*을 수행한다. 간단히 말해서, 해당 변수의 타입이 가질 수 있는 최댓값보다 큰 값은 그 타입이 가질 수 있는 최솟값을 "감싸 돌아갈wrap around" 수 있다. `u8`의 경우에, 256이 0이 되고, 257이 1이 되는 것 등이다. 프로그램은 panic을 일으키지 않을 것이지만, 그 변수는 애초에 의도하지 않은 값을 가지고 있을 것이다. 정수 오버플로우의 래핑 현상에 기대는 것은 에러로 간주된다. 만약 명시적으로 래핑을 하고싶다면, 표준 라이브러리 타입 `Wrapping`을 사용할 수 있다.

### Floating-Point Types
### Numeric Operations
### Booelan
### Character

## compound Types

### Tuple
### Array
