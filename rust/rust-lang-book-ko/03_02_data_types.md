# 03-02 Data Types

러스트에서 사용되는 모든 값들은 특정한 *타입*을 갖는다. 타입은 데이터를 어떻게 다룰지 다룰지 알 수 있도록 러스트에게 어떤 유형의 데이터를 다루는 것인지 알려준다. 여기서 두 종류의 데이터 타입 하위 집합을 다룰 것이다 : 스칼라와 컴파운드.

러스트는 *정적 타입* 언어라는 것을 계속 염두에 두어야 한다. 이 말은 러스트가 모든 변수의 타입을 컴파일 타임에 알고 있어야 한다는 뜻이다. 컴파일러는 대체로 사용하는 값과 변수를 어떻게 사용하는지를 바탕으로 타입을 추론할 수 있다. 다만 여러 가지 타입이 가능한 경우에, 예를 들어 2장에서 `String`을 `parse`를 이용하여 숫자 타입으로 바꾸었을 때 처럼, 타입 어노테이션은 반드시 추가되어야 한다.

```rust
let guess: u32 = "42".parse().expect("Not a number!");
```

만약 여기 타입 어노테이션을 달아놓지 않는다면, 러스트는 다음과 같은 오류를 낼 것이다. 이 오류는 우리가 어떤 타입을 사용하길 원하는지 알기 위해서 컴파일러에게 더 많은 정보를 제공해줘야 함을 뜻한다.

```bash
error[E0282]: type annotations needed
 --> src/main.rs:2:9
  |
2 |     let guess = "42".parse().expect("Not a number!");
  |         ^^^^^
  |         |
  |         cannot infer type for `_`
  |         consider giving `guess` a type
```

다른 데이터 타입의 경우 다른 타입 어노테이션을 볼 수 있다.

## Scalar Types 스칼라 타입

*스칼라* 타입은 하나의 값을 표현한다. 러스트는 네 개의 스칼라 타입을 가지고 있다: 정수, 부동 소수점 소수, boolean, 문자. 이 타입은 다른 언어에서도 보아 왔겠지만, 이를 러스트에서는 어떻게 동작하는지 알아보자.

### Integer 정수

*정수*는 소수부가 없는 숫자이다. 앞선 장에서는 `u32` 타입의 정수형을 사용하였다. 이 타입의 선언은 부호가 없는 32비트 변수임을 나타낸다. (부호가 있는 타입은 `u` 대신 `i`로 시작한다.) 아래 표는 러스트에서 사용되는 정수형을 보여준다. signed, unsigned로 나뉜 다른 열의 타입을 사용하여 정수 값의 타입을 선언할 수 있다.

| Length | Signed | Unsigned |
| ------ | ------ | -------- |
| 8 bit  | i8     | u8       |
| 16 bit | i16    | u16      |
| 32 bit | i32    | u32      |
| 64 bit | i64    | u64      |
| arch   | isize  | usize    |

각각의 타입은 signed 혹은 unsigned이며 명시된 크기를 갖는다. signed, unsigned는 이 숫자가 음수가 될 수 있는지 없는지 여부를 나타낸다. 다르게 말하면, 숫자가 부호를 가져야 하는 경우(signed), 항상 양수이기 때문에 부호가 따로 필요 없는 경우(unsigned)이다.

Signed 숫자는 2의 보수를 사용하여 저장된다.

각각의 signed variant는 숫자를 - (2<sup>n-1</sup>) 에서 2<sup>n-1</sup> - 1 까지의 숫자를 사용한다. 이 때 n은 해당 variant가 사용하는 비트의 수와 같다. 따라서 `i8`은 - (2<sup>7</sup>) 에서 2<sup>7</sup> - 1까지, -128에서 127까지의 값을 저장할 수 있다. unsigned variant는 0에서 2<sup>n</sup> - 1 까지의 값을 저장할 수 있으며, `u8`의 경우 0에서 255까지 저장할 수 있다.

추가로, `isize`와 `usize` 타입은 컴퓨터 환경이 64-bits인지 아닌지에 따라 결정된다. 64-bit 아키텍쳐의 경우 64 bit를, 32-bit 아키텍쳐의 경우 32 bit를 가지게 된다.

아래 테이블과 같은 정수형 리터럴을 사용할 수 있다. byte 리터럴을 제외하고 모든 정수형 리터럴은 `57u8`과 같은 타입 접미사와 `1_000`과 같이 시각적인 구분을 위한 `_`의 사용을 허용합니다.

| Number Literals | Example       |
| Decimal         | `98_222`      |
| Hex             | `0xff`        |
| Octal           | `0o77`        |
| Binary          | `0b1111_0000` |
| Byte(`u8` only) | `b'A'`        |

그렇다면 어떤 타입의 정수를 사용해야 할까? 확실하게 정해진 경우가 아니면 러스트의 기본 값인 i32가 일반적으로는 좋은 선택이다. 이는 일반적으로 가장 빠르기 때문. `isize` 혹은 `usize`는 주로 컬렉션 따위를 인덱싱할 때 사용된다.

  Integer Overflow

  0에서 255 사이의 값을 가질 수 있는 `u8` 타입의 변수가 있다고 하자. 만약 이 값을 허용하는 범위 바깥의 값-256 등-으로 바꾸고자 한다면, *정수 오버플로우 integer overflow*가 발생하게 된다. 러스트는 이 상황을 포함하는 흥미로운 규칙이 있다. 디버그 모드에서 컴파일 할 경우, 러스트는 런타임에 프로그램을 오류에 빠뜨릴 수 있는 정수 오버플로우에 대한 검사를 포함한다. 러스트는 프로그램이 오류로 인해 종료될 때 `panicking`이라는 용어를 사용한다. 이에 대해서는 9장에 더욱 자세히 나와 있다.

  `--release`를 이용하여 릴리즈 모드에서 컴파일을 할 경우, 러스트는 정수 오버플로우에 대해 체크를 하지 않는다. 대신에, 정수 오버플로우가 발생할 경우, 러스트는 *2의 보수 래핑two's complement wrapping*을 수행한다. 간단히 말해서, 해당 변수의 타입이 가질 수 있는 최댓값보다 큰 값은 그 타입이 가질 수 있는 최솟값을 "감싸 돌아갈wrap around" 수 있다. `u8`의 경우에, 256이 0이 되고, 257이 1이 되는 것 등이다. 프로그램은 panic을 일으키지 않을 것이지만, 그 변수는 애초에 의도하지 않은 값을 가지고 있을 것이다. 정수 오버플로우의 래핑 현상에 기대는 것은 에러로 간주된다. 만약 명시적으로 래핑을 하고싶다면, 표준 라이브러리 타입 `Wrapping`을 사용할 수 있다.

### Floating-Point Types 부동 소수점

러스트에는 부동소수점 숫자를 위한 두 가지 기본 타입이 있다. Rust의 부동 소수점 타입은 `f32`와 `f64`로, 각각 32bit, 64bit의 크기를 갖는다. 기본 타입은 `f64`인데, 이는 현대 CPU에서는 `f32`와 거의 같은 속도를 내면서 더 높은 정확성을 가질 수 있기 때문이다.

아래는 부동소수점을 사용하는 것을 보여주는 예이다.

```rust
fn main() {
  let x = 2.0; // f64
  let y: f32 = 3.0; // f32
}
```
부동소수점은 IEEE-754 표준을 따른다.

### Numeric Operations 수학적 연산

러스트는 모든 숫자 타입에 대해 필요한 연산을 지원한다: 덧셈, 뺄셈, 곱셈, 나눗셈, 나머지. 아래 코드는 각각을 `let` 구문에서 사용하는 예이다:

```rust
fn main() {
  // addition
  let sum = 5 + 10;

  // subtraction
  let diff = 95.5 - 4.3;

  // multiplication
  let product = 4 * 30;

  // division
  let quotient = 56.7 / 32.2;

  // remainder
  let remainder = 43 % 5;
}
```

Appendix B에서 러스트가 제공하는 모든 연산자를 찾을 수 있다.

### Booelan 불리언

대부분의 다른 프로그래밍 언어들 처럼, 러스트에서의 Boolean 타입은 `true`와 `false` 두 가지의 값을 가진다. Boolean 타입은 1바이트의 크기를 가진다. 러스트에서는 `bool`로 Boolean 타입을 명시한다. 예를 들어...

```rust
fn main() {
  let t = true;

  let f: bool = false; // with explicit type annotation
}
```

Boolean 타입을 사용하는 주된 활용은 `if` 등을 활용한 조건문을 통해서이다. `if` 부분은 "Control Flow" 부분에서 다룬다.

### Character Type 캐릭터 타입

여태까지는 숫자만 다루었지만, 러스트는 글자 또한 지원한다. 러스트의 `char` 타입은 언어의 가장 원시적인 알파벳 타입이고, 아래 코드는 이를 어떻게 사용하는지를 나타낸다. `char` 리터럴은 홑따옴표를 통해 나타낸다는 것을 명심하자. 반대로 쌍따옴표는 스트링 리터럴을 나타내는데 사용한다.

```rust
fn main() {
  let c = 'z';
  let z = 'ℤ';
  let heart_eyed_cat = '😻';
}
```

러스트의 `char` 타입은 4바이트의 크기를 가지고 있으며, 유니코드 스칼라 값을 나타낸다. 이는 ASCII보다는 더 많은 값을 나타낼 수 있다는 말이다. 한국어, 중국어, 일본어, 이모지, 강세를 나타낸 알파벳, 너비가 0인 space 또한 러스트에서는 유효한 `char`이다.

유니코드 값은 `U+0000` 부터 `U+D7FF`, `U+E000`에서 `U+10FFFF` 값을 가진다. 하지만, "character"는 사실 유니코드에서 존재하는 개념은 아니기 때문에, 인간으로서의 "character"라는 개념이 러스트의 `char` 개념과는 조금 다를 수 있다. 8장의 "Strong UTF-8 Encoded Text with Strings"에서 자세한 내용을 볼 수 있다.

## compound Types 컴파운드 타입

컴파운드 타입은 여러 값을 하나의 타입으로 묶을 수 있다. 러스트는 두 개의 원시 컴파운드 타입을 가지고 있다: 이는 튜플과 어레이이다.

### Tuple 튜플

튜플은 다양한 종류의 타입을 가진 데이터를 하나의 컴파운드 타입으로 묶는 역할을 한다. 튜플의 길이는 정해져 있다. 일단 선언되고 나면 그 크기는 커지거나 작아질 수 없다.

튜플은 ()괄호 내부에 ,콤마로 나뉘어진 값들을 적어서 만들 수 있다. 튜플의 각 자리는 타입을 가지고 있고, 해당 자리의 값들은 같은 타입을 가질 필요는 없다. 아래에서는 타입을 옵셔널하게 적어놓았다.

```rust
fn main() {
  let tup: (i32, f64, u8) = (500, 6.4, 1);
}
```

변수 `tup`는 튜플 전체와 바인딩되는데, 이는 튜플이 단일 컴파운드 요소로 간주되기 때문이다. 튜플로부터 개별 요소를 가져오기 위해서는, 우리는 튜플의 값을 아래와 같이 *패턴 매칭*을 통해 튜플을 해체할 수 있다.

```rust
fn main() {
  let tup = (500, 6.4, 1);

  let (x, y, z) = tup;

  println!("The value of y is : {}", y);
}
```

이 프로그램은 우선 튜플을 생성하고 변수 `tup`에 튜플을 바인딩한다. 그 다음, 패턴과 `let`을 사용하여 `x` `y` `z` 세 가지 변수에 해당 내용을 넣는다.

### Array
