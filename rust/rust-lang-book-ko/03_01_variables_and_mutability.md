# 03-01 Variables and Mutability 변수와 가변성

기본 변수는 *불변*이다. 이는 러스트의 *safety안정성*과 *easy concurrency손쉬운 동시성*이라는 장점을 코드에 사용할 수 있도록 도와주는 장치 중 하나이다. 하지만, 변수를 mutable가변적으로 만드는 것 또한 가능하다. 앞으로 어떻게, 왜 러스트는 사용자가 불변성을 선호할 것을 권장하는지, ?그리고 왜 가끔은 발을 빼고싶어 할 것인지?를 설명랗 것이다.

변수가 *immutable불변*이라는 것은, 값이 변수명에 바인딩 되고 나서부터는 그 값을 변경할 수 없다는 것이다. 이것을 구체적으로 보여주기 위해서, *vatiables*라는 프로젝트를 `cargo new variables`를 이용, 새로 만들어본다.

새로운 *variables* 디렉토리에 *src.main.rs*에 다음 내용을 채워넣는다. 이 내용은 컴파일 되지 않을 것이다.

Filename: src/main.rs

```rust
fn main() {
    let x = 5;
    println!("The value of x is : {}", x);
    x = 6;
    println!("The value of x is : {}", x);
}
```

위 내용을 저장하고 `cargo run`을 이용해 프로그램을 실행해보면, 다음과 같은 결과가 출력된다:

```bash
error[E0384]: cannot assign twice to immutable variable `x`
 --> src/main.rs:4:5
  |
2 |     let x = 5;
  |         -
  |         |
  |         first assignment to `x`
  |         help: make this binding mutable: `mut x`
3 |     println!("The value of x is : {}", x);
4 |     x = 6;
  |     ^^^^^ cannot assign twice to immutable variable
```

이 예시는 프로그램의 오류를 찾는데 컴파일러가 어떤 도움을 주는지를 보여준다. 컴파일러 에러는 짜증날 지 모르지만, 이는 단지 명령하는 바를 프로그램이 안전하게 수행하고 있지 않다는 점을 뜻하는 것이다. 당신이 좋은 프로그래머가 아니라는 것은 아니다.

이 에러 메세지는 에러의 원인이 `cannot assign twice to immutable variable`라는 것을 보여준다. 이는 불변 변수인 `x`에 두 번째 값을 할당하려고 했기 때문이다.

기존에 불변으로 설정한 변수의 값을 변경하는 상황은 버그를 일으킬 수 있다. 따라서 이 점에 대해 컴파일 타임에 에러를 낸다는 것은 중요하다. 만약 코드의 한 부분에서 한 값이 변하지 않을 것임을 가정하고 코드를 짜고, 다른 부분에서 그 값을 바꿔버릴 경우, 앞서 작성한 코드는 의도한 대로 동작하지 않을 가능성이 있기 때문이다. 이러한 버그의 원인은 특히 뒤에 작성한 코드가 값을 가끔씩만 바꿀 경우 잡아내기 어렵다.

만약 개발자가 특정 값이 변하지 않을 것이라고 지정하면, 러스트는 그 값이 정말로 변하지 않을 것임을 컴파일러가 보장한다. 이 말인즉슨 코드를 읽거나, 코드를 쓸 때 이 값이 언제 변할 지 모른다고 생각하며 읽지 않아도 된다. 코드를 이해하는 것이 더 쉬워지는 것이다.

하지만 가변성은 매우 유용하다. 변수는 기본적으로만 불변이기 때문에, 변수명 앞에 `mut`을 붙여줌으로써 가변적으로 만들 수 있다. 값을 가변으로 만들어주는 것에 덧붙여, `mut`는 코드를 읽는 사람으로 하여금 코드의 다른 부분에서 값이 변경될 수도 있다는 점을 전달한다.

*src/main.rs*를 다음과 같이 바꿔본다.

```rust
fn main() {
    let mut x = 5;
    println!("The value of x is : {}", x);
    x = 6;
    println!("The value of x is : {}", x);
}
```

이제 프로그램을 돌리면, 다음과 같은 결과가 나온다:

```bash
$ cargo run
   Compiling variables v0.1.0 (.../TIL/rust/rust-lang-book-ko/projects/03/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.83s
     Running `target/debug/variables`
The value of x is : 5
The value of x is : 6
```

`mut`가 사용되면서 `x`가 바인딩된 대상이 `5`에서 `6`으로 변경되는 것이 가능하다. 몇 가지 경우에, 불변 변수만 있을 때보다 변수를 가변적으로 만드는 것이 코드 작성에 더 편리하기 때문에 변수를 가변적으로 만들고 싶어할 것이다.

버그를 방지하는 점 이외에도 몇 가지 trade-off(희생 및 보완?)가 있다. 예를 들어, 크기가 큰 자료 구조를 사용할 경우, 특정 지점의 인스턴스를 변화시키는(mutating) 것이 복사 후 새롭게 할당된 인스턴스를 반환하는 것 보다 빠를 수 있기 때문이다. 작은 자료 구조의 경우, 새롭게 인스턴스를 생성하고 함수형 프로그래밍 스타일로 쓰는 것이 생각하기에 더 편할 것이고, 이에 따라오는 성능 저하는 그 명확성을 얻는 데 합리적인 페널티일 수 있다.

## 변수와 상수의 차이점들

변수의 값을 바꿀 수 없도록 하는 것은, 다른 프로그래밍 컨셉을 떠올리게 할 지 모른다: 바로 *constants상수*. 마치 불변 변수 처럼 상수는 이름이 바인딩되어 바꿀 수 없는 값이긴 하지만, 변수와 상수 간에는 약간의 차이점이 존재한다.

첫 번째로, 상수에는 `mut`을 쓰는 것이 허용되지 않는다. 상수는 무조건, 항상 불변이다.

두 번째로, 상수를 선언하려면 `let` 키워드 대신 `const` 키워드를 사용해야 하고, 그 타입은 *무조건* annotated달려 있어야 한다. 다음 장인 데이터 타입에서 타입과 타입 어노테이션(꼬리표)에 대해 다룰 것이다. 이 타입 어노테이션은 무조건 달아야 하는 것임을 기억하면 된다.

세 번째로, 상수는 글로벌 스코프를 포함, 어느 스코프에서나 선언될 수 있다. 글로벌 스코프에서 선언되는 점은 코드의 다양한 부분에서 사용될 수 있기 때문에 유용하다.

마지막 차이점은 상수는 *constant expression상수 표현식*에만 지정되어야 한다는 것이다. 함수 또는 런타임에 계산되는 다른 어떤 값의 결과에 쓰이면 안된다.

아래는 `MAX_POINTS`라는 이름의 상수를 선언하고, 그 값을 100,000으로 지정한 것을 보여준다. (러스트의 상수 네이밍 컨벤션은 모두 대문자, 단어 사이의 언더스코어(`_`)를 사용하는 것이고, 숫자 리터럴에는 가독성을 향상시키기 위해 언더스코어를 쓸 수 있다.)

```rust
const MAX_POINTS: u32 = 100_000; // 10_00_00 이런 것도 가능.
```

상수는 선언되어 있는 스코프 내에서, 프로그램이 돌아가는 시간 동안 항상 유효하다. 이는 게임 플레이어의 최고 점수, 빛의 속도 등 애플리케이션 도메인의 다수의 파트에서 사용될 수 있는 값을 쓸 때 유용한 선택지가 된다.

하드코딩된 값을 프로그램 전체에 걸쳐 상수로 선언하는 것은, 추후 유지보수할 개발자들에게 의미를 전달하기에도 매우 유용하다. 또한 하드코딩된 값을 바꿔야 할 부분을 한 곳에 유지하는 것도 추후 값을 변경해야 할 때 매우 도움이 된다.

## Shadowing 섀도잉

2장 튜토리얼에서 본 것 처럼, 새로운 변수를 이전의 변수와 같은 이름으로 지정하는 것이 가능하다. 이렇게 하면 새로운 변수 값이 이전 변수 값을 *shadowing가리게 되는* 것이다. 이를 첫 번째 변수가 두 번째 변수에 의해 가려졌다고 부르는데, 이 말은 이 변수가 사용되면 두 번째 변수의 값이 사용된다는 뜻이다.
다음과 같이 같은 변수명을 사용하고, `let` 키워드 다시 한 번 사용함으로써 변수를 가릴 수 있다.

Filename: src/main.rs

```rust
fn main() {
    let x = 5;

    let x = x + 1;

    let x = x * 2;

    println!("The value of x is: {}", x);
}
```

처음 부분에서, 이 코드에서는 `x`를 `5`와 바인딩한다. 그 다음으로 `let x = `를 사용함으로써 `x`를 가리게 되는데, 여기서 `x`의 원래 값을 가져다가 `1`을 더하게 된다. 따라서 이 값은 `6`이 된다. 세 번째 `let` 구문 또한 `x`를 가리게 되는데, 기존의 값을 `2`만큼 곱하여 `x`의 최종 값을 `12`로 결정한다. 이 프로그램을 돌리면, 다음과 같이 나올 것이다.

```bash
$ cargo run
   Compiling variables v0.1.0 (.../TIL/rust/rust-lang-book-ko/projects/03/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/variables`
The value of x is : 12
```

섀도잉은 변수를 `mut`으로 표시하는 것과는 다르다. 만약 실수로 이 값을 `let` 키워드 없이 재할당하려 한다면 컴파일 타임 오류가 날 것이기 때문이다. `let`을 사용함으로써, 우리는 값을 변화시킬 수 있고, 변화를 준 이후에는 그 변수를 불변으로 설정할 수 있다.

`mut`을 사용하는 것과 또 다른 차이점은, `let` 키워드를 다시 사용함으로써 변수를 새롭게 만들었기 때문에, 값의 이름을 유지시키면서 그 값의 타입을 변경시킬 수 있다는 점이다. 예를 들어, 몇 개의 공백문자를 사용할 지 물어보는 프로그램이 여러 개의 공백 문자를 입력받을 수 있다고 하자. 하지만 정말 저장하고자 하는 것은 그 입력을 숫자로 저장하는 것이다:

```rust
let spaces = "    ";
let spaces = spaces.len();
```

이 구조가 허용되는 이유는 첫 `spaces` 변수가 문자열 타입이고, 앞선 변수와 동일한 이름을 가진 새 변수인 두 번째 `spaces` 변수가 숫자 타입이기 때문이다. 섀도잉은 `spaces_str`, `spaces_num` 등과 같이 다른 이름을 가진 여러 변수를 만드는 것 대신에, 간단하게 `spaces`를 사용할 수 있게 해준다. 하지만, 이를 `mut` 를 붙여 사용하려고 하면 컴파일 타임 에러를 보게 될 것이다.

```rust
let mut spaces = "    ";
spaces = spaces.len();
```

이 에러는 변수의 타입을 변경시키는 것은 허용되지 않는다고 알려준다.

```rust
error[E0308]: mismatched types
  --> src/main.rs:3:14
  |
3 |     spaces = spaces.len();
  |              ^^^^^^^^^^^^ expected `&str`, found `usize`
```

이제 변수가 어떻게 동작하는지 알았으니, 데이터 타입에 대해 다루어보자.