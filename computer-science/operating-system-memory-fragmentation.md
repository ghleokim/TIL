# 메모리 단편화, 페이징과 세그멘테이션 기법

가상메모리 관리. 단편화fragmentation을 해결하기 위해 사용

## 가상 메모리

실행중인 프로세스가 가상의 공간을 참조하여 마치 커다란 물리 메모리를 갖고 있는 것 처럼 사용할 수 있도록 하는 것이다. 실제 메모리 주소 대신 가상의 메모리 주소를 주는 방식을 말한다.

가상 메모리는 각 프로세스당 메인메모리와 동일한 크기로 하나씩 할당된다. 그 공간은 보조기억장치(HDD,SSD) 공간을 이용한다. 프로세스의 일부만 메모리에 로드하고 나머지는 보조기억장치에 두는 형태이다.

## Memory Fragmentation메모리 단편화란?

메모리 공간이 작은 조각으로 나뉘어져 사용가능한 **메모리가 충분히 존재하지만 할당이 불가능한 상태**를 보고 메모리 단편화가 발생했다고 한다.

**내부 단편화**는 메모리를 할당할 때 프로세스가 **필요한 양보다 더 큰 메모리가 할당되어서 메모리 공간이 낭비**되는 상황이다. 예를 들어, 메모장을 켤 때 4kb의 메모리 공간을 할당 받았지만 1kb만을 사용하고 있다면, 이는 내부 단편화가 3kb만큼 생긴 것이라고 볼 수 있다.

메모리가 할당되고 해제되는 작업이 반복될 때, 빈 메모리 공간은 중간중간 존재하게 된다. 이러할 경우, **외부 단편화**는 중간중간 사용하지 않는 메모리가 많이 존재헤서 **총 메모리 공간은 충분하지만 실제로 할당할 수 없는 상황**이다. 예를 들어, 메모리 주소의 시작 부분 부터 8mb짜리 프로세스, 이어서 16mb짜리 프로세스가 할당되었다고 가정할 때, 8mb짜리 프로세스를 종료시키면 메모리의 시작부터 8mb만큼의 공간이 생긴다. 이렇게 빈 메모리가 계속해서 쌓이다가, 8mb짜리 메모리 공간이 가장 큰 공간인 상황에서 9mb짜리 프로세스를 할당해야 한다면, 실제로는 넉넉한 메모리 용량을 가지고 있음에도 불구하고 프로세스에 할당할 메모리가 없는 상황이 생긴다.

## Segmentation세그멘테이션 기법 → 내부 단편화

메모리를 서로 크기가 다른 논리적인 블록 단위로 분할하고, 메모리를 할당하여 물리 주소를 논리 주소로 변환하는 것을 말한다. 이 때 분할한 단위의 블록이 **세그먼트**이다. 프로그램 세그먼트에는 프로그램의 메인 함수, 유틸리티 함수, 자료 구조 등이 포함된다. 또한, 블록은 미리 분할되지 않고 메모리를 사용하는 시점에 할당되며, 각 세그먼트는 연속적인 공간에 저장한다.

이렇게 분할한 세그먼트는 **segment map table세그먼트 맵 테이블**을 사용하여 관리한다. OS는 각 프로세스의 세그먼트 테이블과 가용 메모리 블록, 세그먼트 번호, 세그먼트 사이즈 및 메인 메모리상의 메모리 주소 등을 관리한다.

테이블에는 각 세그먼트의 시작 주소(base)와 길이 정보(limit, length)가 담겨있다. 이 테이블은 offset 단위로 세그먼트를 관리할 수 있게 한다. 이와 같이 메모리를 논리적으로 나누어놓은 상태에서, 시작 주소와 offset 값을 통해 물리적 위치로 변환할 수 있기 때문에 관리가 편해진다.

## Paging페이징 기법 → 외부 단편화

가상 메모리를 **고정된 크기**로 나누어 메모리를 관리하는 것. 이 크기는 2의 배수로, 보통 512바이트~8192바이트 사이로 한다. 이 때 고정된 크기로 나누어진 블록을 **페이지**라고 한다.

비슷한 방식으로, 메인 메모리(물리 메모리)는 작은 고정된 크기의 블록으로 나뉘어지고, 이 블록을 **프레임**이라고 한다. 각 프레임은 페이지와 같은 크기 단위로 관리된다.

사용하지 않는 프레임을 페이지에 옮기고, 필요한 메모리를 페이지 단위로 프레임에 옮기는 기법이다. 페이지와 프레임을 대응시키는 page mapping 과정이 필요하기 때문에, paging table을 만든다. 페이징 기법을 사용하면 연속적이지 않은 공간 또한 활용 가능하기 때문에, 외부 단편화 문제를 해결할 수 있다.

## 세그멘테이션과 페이징의 중요한 차이점

- 메모리 사이즈

    페이징에서 프로세스 주소 공간은 페이지라고 불리는 고정된 크기의 블록으로 쪼개진다.

    세그멘테이션에서 프로세스 주소 공간은 섹션이라고 불리는 다양한 크기의 블록으로 쪼개진다.

- Accountability책임 및 주체

    페이징에서는 OS가 메모리를 페이지로 나눈다.

    세그멘테이션에서는 컴파일러가 세그먼트 크기, 가상 주소와 물리 주소를 계산한다.

- 사이즈

    페이지 사이즈는 가용한 메모리의 크기에 따라 결정된다.

    섹션의 크기는 사용자에 의해 결정된다.

- 속도

    페이징 기법은 메모리 접근의 측면에서 조금 더 빠르다.

    세그멘테이션은 더 느리다.

- Fragmentation파편화

    페이징에서 일부 페이지의 불충분한 이용은 내부 파편화를 일으킬 수 있다.

    세그멘테이션은 특정 메모리 블록이 아예 사용되지 않는 등의 상황에서 외부 파편화를 일으킬 수 있다.

- 논리 주소

    페이징 과정에서, 논리 주소는 페이지 번호와 페이지 offset으로 나뉜다.

    세그멘테이션 과정에서, 논리 주소는 섹션 번호와 섹션 오프셋으로 나뉜다.

## Memory Pool메모리 풀

필요한 메모리 공간을 필요한 크기, 갯수만큼 사용자가 직접 지정하여 미리 할당 받아놓고, 필요할 마다 사용하고 반납하는 기법.

메모리 풀 없이 동적 할당과 해제를 반복하다보면, 메모리의 랜덤한 위치(사실 알고리즘에 의한 위치)에 할당과 해제가 반복되면서 단편화를 일으킬 수 있지만, 미리 공간을 할당해놓고 사용하기 때문에 **외부 단편화가 발생하지 않는다.** 또한 필요한 크기만큼 할당해놓기 때문에 **내부 단편화 또한 발생하지 않는다.**

메모리의 할당, 해제가 잦을 경우에 쓰면 효과적이다.

참고

[메모리 단편화(Memory Fragmentation)가 무엇이고 왜 발생하는가?](https://jeong-pro.tistory.com/91)
[Difference between Paging and Segmentation](https://www.tutorialspoint.com/difference-between-paging-and-segmentation)