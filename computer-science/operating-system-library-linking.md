# static linking, dynamic linking

linking : 라이브러리 코드를 사용하는 방법에 대한 차이. 각각의 장단점이 있다.

![static-link-and-dynamic-link](https://user-images.githubusercontent.com/52501513/86215520-a2070600-bbb7-11ea-924b-f5746663fd45.png)

## static linking

정적 라이브러리를 사용하여 컴파일하면 링커가 필요한 부분을 찾아 실행파일에 복사한다. 따로 라이브러리가 필요 없기 때문에 **컴파일 시간이 단축**된다. 구현한 코드를 라이브러리화 시켜서 **기술 유출 방지로 사용**할 수도 있다.

하지만 실행 파일 내에 라이브러리 코드가 저장되기 때문에 **메모리를 많이 잡아먹는다.**

## dynamic linking

코드가 실행 되는 시점이 되기 전까지 링크가 진행되지 않는다. 코드가 실행 될 점에는 우선 메모리에서 해당 라이브러리를 찾는다. 운영체제가 한 번 메모리에 load시켜주면, 이후 다른 코드에서 그 라이브러리를 찾을 경우 메모리를 더 소비하지 않고 해당 라이브러리를 사용할 수 있는 것이다.

동적 라이브러리는 프로그램이 실행될 때 링크되는 시스템 라이브러리이다. 동적 링크를 이용하면, 각 라이브러리 루틴에는 stub이 포함된다. stub라는 것은 작은 코드조각인데, 메모리에 상주하는 라이브러리 루틴을 어떻게 참조하는지, 필요한 라이브러리가 메모리에 없을 경우 어떻게 라이브러리를 로드하는지를 알려주는 조각이다. stub는 자기자신을 루틴의 주소로 대체replace하거나, 루틴을 실행시킨다.

윈도에서는 dll이라고 부르고, linux/unix에서는 shared library라고 부른다.

- 장점

    메모리의 요구사항이 훨씬 적다.
    
    라이브러리의 버전이 바뀌었을 때 해당 라이브러리만 교체하면 된다.

- 단점

    다른 위치의 메모리에 접근하기 때문에 성능상 오버헤드가 생긴다.

    만약 hello world cout 파일을 만들고 이것을 static linking으로 컴파일 했을 때, dynamic linking으로 컴파일 했을 때 파일의 크기가 달라진다. static > dynamic

참고

[운영체제 : static linking and dynamic linking](https://jhnyang.tistory.com/42)